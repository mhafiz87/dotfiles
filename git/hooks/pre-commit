#!/bin/bash

global_hook() {
    # Path to the commit message file
    COMMIT_MSG_FILE=$1

    # Read the commit message
    COMMIT_MSG=$(cat $COMMIT_MSG_FILE)

    # Extract header, body, and footer
    HEADER=$(echo "$COMMIT_MSG" | head -n 1)
    BODY=$(echo "$COMMIT_MSG" | sed -n '3,/^$/p' | sed '/^$/d')
    FOOTER=$(echo "$COMMIT_MSG" | grep -i -E "^(JIRA:|MISTY:|BREAKING CHANGE:|[A-Z]+-[0-9]+:|Closes #|Fixes #|Resolves #)")

    # Conventional Commit pattern
    # Format: [optional scope]: 
    # Example: feat(api): add user authentication
    HEADER_PATTERN='^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\([a-z0-9-]+\))?: .{1,}'

    if ! [[ $HEADER =~ $HEADER_PATTERN ]]; then
      echo -e "\e[1;31mERROR: Commit message does not follow conventional format.\e[0m"
      echo -e "\e[1;31mERROR: $HEADER.\e[0m"
      echo ""
      echo "Required format:"
      echo '```'
      echo -e "\e[38;2;255;165;0m<type>\e[0m\e[92m(<optional scope>)\e[0m: \e[38;2;255;165;0m<description>\e[0m"
      echo -e "\e[3;90m<empty line separator>\e[0m"
      echo "<optional body>"
      echo -e "\e[3;90m<empty line separator>\e[0m"
      echo "<optional footer>"
      echo '```'
      echo ""
      echo "Supported types: feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert"
      echo ""
      echo -e "\e[3;90mExample:\e[0m"
      echo -e "feat(api): add user authentication  \e[3;90m# message\e[0m"
      echo ""
      echo -e "Uses httpx requests api.  \e[3;90m# body\e[0m"
      echo ""
      echo -e "JIRA: DM25AUTO-123  \e[3;90m# footer\e[0m"
      echo ""
      echo -e "\e[3;90mExample with breaking feature without any footer (exclamation after type or scope):\e[0m"
      echo -e "feat(serial)!: add user authentication  \e[3;90m# message\e[0m"
      echo ""
      echo -e "New serial device replacing old.  \e[3;90m# body\e[0m"
      echo ""
      echo -e "\e[3;90mReferences:"
      echo "1. https://www.conventionalcommits.org/en/v1.0.0/#specification"
      echo -e "2. https://gist.github.com/qoomon/5dfcdf8eec66a051ecd85625518cfd13\e[0m"
      echo ""
      exit 1
    fi

    # Check if description starts with a capital letter
    DESCRIPTION=$(echo "$HEADER" | sed -E 's/^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\([a-z0-9-]+\))?: //')
    FIRST_CHAR=$(echo "$DESCRIPTION" | cut -c1)

    if [[ "$FIRST_CHAR" =~ [A-Z] ]]; then
      echo -e "\e[1;31mERROR: Description should not start with a capital letter\e[0m"
      exit 1
    fi

    # Check if description ends with a period
    if [[ "$DESCRIPTION" =~ \.$ ]]; then
      echo -e "\e[1;31mERROR: Description should not end with a period\e[0m"
      exit 1
    fi

    # Check if commit message is too long (>72 characters)
    if [[ ${#HEADER} -gt 72 ]]; then
      echo -e "\e[93mWARNING: Commit message is longer than 72 characters\e[0m"
    fi

    # Check body format if it exists
    if [[ -n "$BODY" ]]; then
      # Check if body lines are wrapped at 72 characters
      while IFS= read -r line; do
        if [[ ${#line} -gt 72 ]]; then
          echo -e "\e[93mWARNING: Body line longer than 72 characters:\e[0m"
          echo -e "\e[38;2;255;165;0m$line\e[0m"
        fi
      done <<< "$BODY"

      # Check if body starts with a capital letter
      BODY_FIRST_CHAR=$(echo "$BODY" | head -n 1 | cut -c1)
      if ! [[ "$BODY_FIRST_CHAR" =~ [A-Z] ]]; then
        echo -e "\e[93mWARNING: Body should start with a capital letter\e[0m"
      fi
    fi

    # Check footer format if it exists
    if [[ -n "$FOOTER" ]]; then
      # Check for breaking changes format
      BREAKING_CHANGES=$(echo "$FOOTER" | grep -i "^BREAKING CHANGE:")
      if [[ -n "$BREAKING_CHANGES" && ! "$HEADER" =~ ^(feat|fix) ]]; then
        echo -e "\e[93mWARNING: Breaking changes should be in feat or fix type commits\e[0m"
      fi

      # # Check for issue references format
      # ISSUE_REFS=$(echo "$FOOTER" | grep -E "(Closes|Fixes|Resolves) #[0-9]+")
      # if [[ -n "$ISSUE_REFS" ]]; then
      #   INVALID_REFS=$(echo "$ISSUE_REFS" | grep -v -E "^(Closes|Fixes|Resolves) #[0-9]+$")
      #   if [[ -n "$INVALID_REFS" ]]; then
      #     echo -e "\e[93mWARNING: Issue references should follow format: 'Closes/Fixes/Resolves #123'\e[0m"
      #   fi
      # fi
    fi

    # Python
    # Git pre-commit hook using Ruff to sort imports, check, and fix issues

    # Store list of staged Python files
    STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.py$')

    if [[ "$STAGED_FILES" = "" ]]; then
      echo -e "\e[1mNo Python files staged for commit. Skipping Ruff checks.\e[0m"
      exit 0
    fi

    echo -e "\e[1mRunning Ruff on staged Python files...\e[0m"

    # First, sort imports
    echo -e "\e[1mSorting imports with Ruff...\e[0m"
    ruff check --select I --fix $STAGED_FILES

    # Then run Ruff to check and fix other issues
    echo -e "\e[1mRunning Ruff checks and fixes...\e[0m"
    ruff check --fix $STAGED_FILES

    # Check docstrings
    # D102: undocumented-public-method
    # D103: undocumented-public-function
    # D105: undocumented-magic-method
    # D414: empty-docstring-section
    # D419: empty-docstring
    echo -e "\e[1mRunning Ruff checks for dosctring...\e[0m"
    ruff check --select Q002,D102,D103,D105,D414,D419 --fix $STAGED_FILES

    # Check if any files were modified by Ruff
    if git diff --name-only | grep -E '\.py$' > /dev/null; then
      echo -e "\e[1mRuff made changes. Adding modified files to staging area.\e[0m"
      git add $STAGED_FILES
    fi

    # Run a final check to ensure all issues are fixed or properly ignored
    echo -e "\e[1mRunning final verification...\e[0m"
    if ! ruff check $STAGED_FILES; then
      echo -e "❌ \e1mRuff found issues that couldn't be automatically fixed."
      echo -e "Please fix the remaining issues and try committing again.\e[0m"
      exit 1
    fi

    echo "✅ Ruff checks passed!"

    exit 0
}

# Check if local pre-commit hook exists

SCRIPT_DIR="$(pwd)/${BASH_SOURCE[0]}"
LOCAL_HOOK="$(git rev-parse --show-toplevel)"'/.git/hooks/commit-msg'

if [[ "$LOCAL_HOOK" == *":"* ]]; then
  # echo "The string contains a colon."
    # lowercase first letter then remove colon
    ADJUSTED=$(echo "${LOCAL_HOOK,}" | sed 's/://g; s/^/\//')
else
    ADJUSTED=$LOCAL_HOOK
    # echo "The string does not contain a colon."
fi


if [ "$SCRIPT_DIR" = "$ADJUSTED" ]; then
    echo "Local hook is the global hook. Using global hook..."
    global_hook "$@"
elif [ -f "$ADJUSTED" ] && [ -x "$ADJUSTED" ]; then
    echo "Using local pre-commit hook..."
    exec "$LOCAL_HOOK" "$@"
else
    echo "Using global pre-commit hook..."
fi

